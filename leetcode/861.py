# 有一个二维矩阵 A 其中每个元素的值为 0 或 1 。
# 移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。
# 在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。
# 返回尽可能高的分数。

# 贪心算法
# 对于最终达到最高分数移动的每一步来说，可以任意选择，最终效果是一样的。
# 所以可以先移动行，再移动列
class Solution:
    def matrixScore(self, A) -> int:
        # 行、列
        m, n = len(A), len(A[0])
        # 要想使得结果最大， 所以每一行的第一个位置都是1，加上第0列的所有值
        res = m * (1 << (n - 1))
        # 从第1列开始遍历
        for j in range(1, n):
            # 统计每一列中1和0的个数，如果0的个数比1多，则移动（即将0变为1，1变为0）
            ones = 0
            for i in range(m):
                # 如果原来该行第一个位置为1，则不需要移动该行，1还是1，0还是0
                if A[i][0] == 1:
                    ones += A[i][j]
                else:
                    # 如果原来该行的第一个位置为0，则会移动改行，1变为0，0变为1，所以统计每一列1的个数，则应该 + 1 - A[i][j]
                    ones += 1 - A[i][j]
            res += max(ones, m - ones) * (1 << (n - j - 1))
        return res
